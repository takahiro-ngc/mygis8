{"version":3,"sources":["../../../../src/lib/parsers/parse-shp.ts"],"names":["BinaryChunkReader","parseSHPHeader","parseRecord","LITTLE_ENDIAN","BIG_ENDIAN","SHP_HEADER_SIZE","SHP_RECORD_HEADER_SIZE","STATE","EXPECTING_HEADER","EXPECTING_RECORD","END","ERROR","SHPParser","constructor","options","maxRewindBytes","geometries","write","arrayBuffer","binaryReader","state","parseState","result","end","error","parseSHP","shpParser","parseSHPInBatches","asyncIterator","parser","headerReturned","header","length","dataView","getDataView","progress","bytesUsed","bytesTotal","rows","currentIndex","hasAvailableBytes","recordHeaderView","recordHeader","recordNumber","getInt32","byteLength","type","rewind","invalidRecord","recordView","geometry","push","ended","message"],"mappings":"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","sourcesContent":["import type {LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {BinaryGeometry} from '@loaders.gl/schema';\nimport BinaryChunkReader from '../streaming/binary-chunk-reader';\nimport {parseSHPHeader} from './parse-shp-header';\nimport {parseRecord} from './parse-shp-geometry';\n\nconst LITTLE_ENDIAN = true;\nconst BIG_ENDIAN = false;\n\nconst SHP_HEADER_SIZE = 100;\n// According to the spec, the record header is just 8 bytes, but here we set it\n// to 12 so that we can also access the record's type\nconst SHP_RECORD_HEADER_SIZE = 12;\n\nconst STATE = {\n  EXPECTING_HEADER: 0,\n  EXPECTING_RECORD: 1,\n  END: 2,\n  ERROR: 3\n};\n\ntype SHPResult = {\n  geometries: [];\n  header?: {};\n  error?: string;\n};\n\nclass SHPParser {\n  options?: any = {};\n  binaryReader = new BinaryChunkReader({maxRewindBytes: SHP_RECORD_HEADER_SIZE});\n  state = STATE.EXPECTING_HEADER;\n  result: SHPResult = {\n    geometries: []\n  };\n\n  constructor(options?: LoaderOptions) {\n    this.options = options;\n  }\n\n  write(arrayBuffer: ArrayBuffer) {\n    this.binaryReader.write(arrayBuffer);\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n  }\n\n  end() {\n    this.binaryReader.end();\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n    // this.result.progress.bytesUsed = this.binaryReader.bytesUsed();\n    if (this.state !== STATE.END) {\n      this.state = STATE.ERROR;\n      this.result.error = 'SHP incomplete file';\n    }\n  }\n}\n\nexport function parseSHP(arrayBuffer: ArrayBuffer, options?: object): BinaryGeometry[] {\n  const shpParser = new SHPParser(options);\n  shpParser.write(arrayBuffer);\n  shpParser.end();\n\n  // @ts-ignore\n  return shpParser.result;\n}\n\n/**\n * @param asyncIterator\n * @param options\n * @returns\n */\nexport async function* parseSHPInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: object\n): AsyncIterable<BinaryGeometry | object> {\n  const parser = new SHPParser(options);\n  let headerReturned = false;\n  for await (const arrayBuffer of asyncIterator) {\n    parser.write(arrayBuffer);\n    if (!headerReturned && parser.result.header) {\n      headerReturned = true;\n      yield parser.result.header;\n    }\n\n    if (parser.result.geometries.length > 0) {\n      yield parser.result.geometries;\n      parser.result.geometries = [];\n    }\n  }\n  parser.end();\n  if (parser.result.geometries.length > 0) {\n    yield parser.result.geometries;\n  }\n\n  return;\n}\n\n/**\n * State-machine parser for SHP data\n *\n * Note that whenever more data is needed, a `return`, not a `break`, is\n * necessary, as the `break` keeps the context within `parseState`, while\n * `return` releases context so that more data can be written into the\n * BinaryChunkReader.\n *\n * @param  state Current state\n * @param  result An object to hold result data\n * @param  binaryReader\n * @return State at end of current parsing\n */\n/* eslint-disable complexity, max-depth */\nfunction parseState(\n  state: number,\n  result: {[key: string]: any},\n  binaryReader: BinaryChunkReader,\n  options: {shp?: any}\n): number {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    try {\n      switch (state) {\n        case STATE.ERROR:\n        case STATE.END:\n          return state;\n\n        case STATE.EXPECTING_HEADER:\n          // Parse initial file header\n          const dataView = binaryReader.getDataView(SHP_HEADER_SIZE);\n          if (!dataView) {\n            return state;\n          }\n\n          result.header = parseSHPHeader(dataView);\n          result.progress = {\n            bytesUsed: 0,\n            bytesTotal: result.header.length,\n            rows: 0\n          };\n          // index numbering starts at 1\n          result.currentIndex = 1;\n          state = STATE.EXPECTING_RECORD;\n          break;\n\n        case STATE.EXPECTING_RECORD:\n          while (binaryReader.hasAvailableBytes(SHP_RECORD_HEADER_SIZE)) {\n            const recordHeaderView = binaryReader.getDataView(SHP_RECORD_HEADER_SIZE) as DataView;\n            const recordHeader = {\n              recordNumber: recordHeaderView.getInt32(0, BIG_ENDIAN),\n              // 2 byte words; includes the four words of record header\n              byteLength: recordHeaderView.getInt32(4, BIG_ENDIAN) * 2,\n              // This is actually part of the record, not the header...\n              type: recordHeaderView.getInt32(8, LITTLE_ENDIAN)\n            };\n\n            if (!binaryReader.hasAvailableBytes(recordHeader.byteLength - 4)) {\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE);\n              return state;\n            }\n\n            const invalidRecord =\n              recordHeader.byteLength < 4 ||\n              recordHeader.type !== result.header.type ||\n              recordHeader.recordNumber !== result.currentIndex;\n\n            // All records must have at least four bytes (for the record shape type)\n            if (invalidRecord) {\n              // Malformed record, try again, advancing just 4 bytes\n              // Note: this is a rewind because binaryReader.getDataView above\n              // moved the pointer forward 12 bytes, so rewinding 8 bytes still\n              // leaves us 4 bytes ahead\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE - 4);\n            } else {\n              // Note: type is actually part of the record, not the header, so\n              // rewind 4 bytes before reading record\n              binaryReader.rewind(4);\n\n              const recordView = binaryReader.getDataView(recordHeader.byteLength) as DataView;\n              const geometry = parseRecord(recordView, options);\n              result.geometries.push(geometry);\n\n              result.currentIndex++;\n              result.progress.rows = result.currentIndex - 1;\n            }\n          }\n\n          if (binaryReader.ended) {\n            state = STATE.END;\n          }\n\n          return state;\n\n        default:\n          state = STATE.ERROR;\n          result.error = `illegal parser state ${state}`;\n          return state;\n      }\n    } catch (error) {\n      state = STATE.ERROR;\n      result.error = `SHP parsing failed: ${(error as Error)?.message}`;\n      return state;\n    }\n  }\n}\n"],"file":"parse-shp.js"}