{"version":3,"sources":["../../../../src/lib/streaming/binary-chunk-reader.ts"],"names":["BinaryChunkReader","constructor","options","maxRewindBytes","offset","arrayBuffers","ended","write","arrayBuffer","push","end","hasAvailableBytes","bytes","bytesAvailable","byteLength","findBufferOffsets","selectedBuffers","i","length","buf","start","Math","abs","getDataView","bufferOffsets","Error","bufferIndex","view","DataView","disposeBuffers","_combineArrayBuffers","shift","bufferOffset","result","Uint8Array","resultOffset","sourceArray","set","subarray","buffer","skip","rewind"],"mappings":"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","sourcesContent":["export default class BinaryChunkReader {\n  offset: number;\n  arrayBuffers: ArrayBuffer[];\n  ended: boolean;\n  maxRewindBytes: number;\n\n  constructor(options?: {[key: string]: any}) {\n    const {maxRewindBytes = 0} = options || {};\n\n    /** current global offset into current array buffer*/\n    this.offset = 0;\n    /** current buffer from iterator */\n    this.arrayBuffers = [];\n    this.ended = false;\n\n    /** bytes behind offset to hold on to */\n    this.maxRewindBytes = maxRewindBytes;\n  }\n  /**\n   * @param arrayBuffer\n   */\n  write(arrayBuffer: ArrayBuffer): void {\n    this.arrayBuffers.push(arrayBuffer);\n  }\n\n  end(): void {\n    this.arrayBuffers = [];\n    this.ended = true;\n  }\n\n  /**\n   * Has enough bytes available in array buffers\n   *\n   * @param bytes Number of bytes\n   * @return boolean\n   */\n  hasAvailableBytes(bytes: number): boolean {\n    let bytesAvailable = -this.offset;\n    for (const arrayBuffer of this.arrayBuffers) {\n      bytesAvailable += arrayBuffer.byteLength;\n      if (bytesAvailable >= bytes) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Find offsets of byte ranges within this.arrayBuffers\n   *\n   * @param  bytes Byte length to read\n   * @return Arrays with byte ranges pointing to this.arrayBuffers, Output type is nested array, e.g. [ [0, [1, 2]], ...]\n   */\n  findBufferOffsets(bytes: number): any[] | null {\n    let offset = -this.offset;\n    const selectedBuffers: any = [];\n\n    for (let i = 0; i < this.arrayBuffers.length; i++) {\n      const buf = this.arrayBuffers[i];\n\n      // Current buffer isn't long enough to reach global offset\n      if (offset + buf.byteLength <= 0) {\n        offset += buf.byteLength;\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // Find start/end offsets for this buffer\n      // When offset < 0, need to skip over Math.abs(offset) bytes\n      // When offset > 0, implies bytes in previous buffer, start at 0\n      const start = offset <= 0 ? Math.abs(offset) : 0;\n      let end: number;\n\n      // Length of requested bytes is contained in current buffer\n      if (start + bytes <= buf.byteLength) {\n        end = start + bytes;\n        selectedBuffers.push([i, [start, end]]);\n        return selectedBuffers;\n      }\n\n      // Will need to look into next buffer\n      end = buf.byteLength;\n      selectedBuffers.push([i, [start, end]]);\n\n      // Need to read fewer bytes in next iter\n      bytes -= buf.byteLength - start;\n      offset += buf.byteLength;\n    }\n\n    // Should only finish loop if exhausted all arrays\n    return null;\n  }\n\n  /**\n   * Get the required number of bytes from the iterator\n   *\n   * @param bytes Number of bytes\n   * @return DataView with data\n   */\n  getDataView(bytes: number): DataView | null {\n    const bufferOffsets = this.findBufferOffsets(bytes);\n    // return `null` if not enough data, except if end() already called, in\n    // which case throw an error.\n    if (!bufferOffsets && this.ended) {\n      throw new Error('binary data exhausted');\n    }\n\n    if (!bufferOffsets) {\n      // @ts-ignore\n      return null;\n    }\n\n    // If only one arrayBuffer needed, return DataView directly\n    if (bufferOffsets.length === 1) {\n      const [bufferIndex, [start, end]] = bufferOffsets[0];\n      const arrayBuffer = this.arrayBuffers[bufferIndex];\n      const view = new DataView(arrayBuffer, start, end - start);\n\n      this.offset += bytes;\n      this.disposeBuffers();\n      return view;\n    }\n\n    // Concatenate portions of multiple ArrayBuffers\n    const view = new DataView(this._combineArrayBuffers(bufferOffsets));\n    this.offset += bytes;\n    this.disposeBuffers();\n    return view;\n  }\n\n  /**\n   * Dispose of old array buffers\n   */\n  disposeBuffers(): void {\n    while (\n      this.arrayBuffers.length > 0 &&\n      this.offset - this.maxRewindBytes >= this.arrayBuffers[0].byteLength\n    ) {\n      this.offset -= this.arrayBuffers[0].byteLength;\n      this.arrayBuffers.shift();\n    }\n  }\n\n  /**\n   * Copy multiple ArrayBuffers into one contiguous ArrayBuffer\n   *\n   * In contrast to concatenateArrayBuffers, this only copies the necessary\n   * portions of the source arrays, rather than first copying the entire arrays\n   * then taking a part of them.\n   *\n   * @param bufferOffsets List of internal array offsets\n   * @return New contiguous ArrayBuffer\n   */\n  _combineArrayBuffers(bufferOffsets: any[]): ArrayBufferLike {\n    let byteLength: number = 0;\n    for (const bufferOffset of bufferOffsets) {\n      const [start, end] = bufferOffset[1];\n      byteLength += end - start;\n    }\n\n    const result = new Uint8Array(byteLength);\n\n    // Copy the subarrays\n    let resultOffset: number = 0;\n    for (const bufferOffset of bufferOffsets) {\n      const [bufferIndex, [start, end]] = bufferOffset;\n      const sourceArray = new Uint8Array(this.arrayBuffers[bufferIndex]);\n      result.set(sourceArray.subarray(start, end), resultOffset);\n      resultOffset += end - start;\n    }\n\n    return result.buffer;\n  }\n  /**\n   * @param bytes\n   */\n  skip(bytes: number): void {\n    this.offset += bytes;\n  }\n  /**\n   * @param bytes\n   */\n  rewind(bytes: number): void {\n    // TODO - only works if offset is already set\n    this.offset -= bytes;\n  }\n}\n"],"file":"binary-chunk-reader.js"}