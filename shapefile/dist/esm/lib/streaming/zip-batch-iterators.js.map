{"version":3,"sources":["../../../../src/lib/streaming/zip-batch-iterators.ts"],"names":["zipBatchIterators","iterator1","iterator2","batch1","batch2","iterator1Done","iterator2Done","length","value","done","next","batch","extractBatch","batchLength","Math","min","slice","splice"],"mappings":"AAMA,OAAO,gBAAgBA,iBAAhB,CACLC,SADK,EAELC,SAFK,EAGsC;AAC3C,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,aAAsB,GAAG,KAA7B;AACA,MAAIC,aAAsB,GAAG,KAA7B;;AAIA,SAAO,CAACD,aAAD,IAAkB,CAACC,aAA1B,EAAyC;AACvC,QAAIH,MAAM,CAACI,MAAP,KAAkB,CAAlB,IAAuB,CAACF,aAA5B,EAA2C;AACzC,YAAM;AAACG,QAAAA,KAAD;AAAQC,QAAAA;AAAR,UAAgB,MAAMR,SAAS,CAACS,IAAV,EAA5B;;AACA,UAAID,IAAJ,EAAU;AACRJ,QAAAA,aAAa,GAAG,IAAhB;AACD,OAFD,MAEO;AACLF,QAAAA,MAAM,GAAGK,KAAT;AACD;AACF,KAPD,MAOO,IAAIJ,MAAM,CAACG,MAAP,KAAkB,CAAlB,IAAuB,CAACD,aAA5B,EAA2C;AAChD,YAAM;AAACE,QAAAA,KAAD;AAAQC,QAAAA;AAAR,UAAgB,MAAMP,SAAS,CAACQ,IAAV,EAA5B;;AACA,UAAID,IAAJ,EAAU;AACRH,QAAAA,aAAa,GAAG,IAAhB;AACD,OAFD,MAEO;AACLF,QAAAA,MAAM,GAAGI,KAAT;AACD;AACF;;AAED,UAAMG,KAAK,GAAGC,YAAY,CAACT,MAAD,EAASC,MAAT,CAA1B;;AACA,QAAIO,KAAJ,EAAW;AACT,YAAMA,KAAN;AACD;AACF;AACF;;AASD,SAASC,YAAT,CAAsBT,MAAtB,EAAwCC,MAAxC,EAA6E;AAC3E,QAAMS,WAAmB,GAAGC,IAAI,CAACC,GAAL,CAASZ,MAAM,CAACI,MAAhB,EAAwBH,MAAM,CAACG,MAA/B,CAA5B;;AACA,MAAIM,WAAW,KAAK,CAApB,EAAuB;AACrB,WAAO,IAAP;AACD;;AAGD,QAAMF,KAAiB,GAAG,CAACR,MAAM,CAACa,KAAP,CAAa,CAAb,EAAgBH,WAAhB,CAAD,EAA+BT,MAAM,CAACY,KAAP,CAAa,CAAb,EAAgBH,WAAhB,CAA/B,CAA1B;AAGAV,EAAAA,MAAM,CAACc,MAAP,CAAc,CAAd,EAAiBJ,WAAjB;AACAT,EAAAA,MAAM,CAACa,MAAP,CAAc,CAAd,EAAiBJ,WAAjB;AACA,SAAOF,KAAP;AACD","sourcesContent":["/**\n * Zip two iterators together\n *\n * @param iterator1\n * @param iterator2\n */\nexport async function* zipBatchIterators(\n  iterator1: AsyncIterator<any[]>,\n  iterator2: AsyncIterator<any[]>\n): AsyncGenerator<number[][], void, unknown> {\n  let batch1 = [];\n  let batch2 = [];\n  let iterator1Done: boolean = false;\n  let iterator2Done: boolean = false;\n\n  // TODO - one could let all iterators flow at full speed using `Promise.race`\n  // however we might end up with a big temporary buffer\n  while (!iterator1Done && !iterator2Done) {\n    if (batch1.length === 0 && !iterator1Done) {\n      const {value, done} = await iterator1.next();\n      if (done) {\n        iterator1Done = true;\n      } else {\n        batch1 = value;\n      }\n    } else if (batch2.length === 0 && !iterator2Done) {\n      const {value, done} = await iterator2.next();\n      if (done) {\n        iterator2Done = true;\n      } else {\n        batch2 = value;\n      }\n    }\n\n    const batch = extractBatch(batch1, batch2);\n    if (batch) {\n      yield batch;\n    }\n  }\n}\n\n/**\n * Extract batch of same length from two batches\n *\n * @param batch1\n * @param batch2\n * @return array | null\n */\nfunction extractBatch(batch1: number[], batch2: number[]): number[][] | null {\n  const batchLength: number = Math.min(batch1.length, batch2.length);\n  if (batchLength === 0) {\n    return null;\n  }\n\n  // Non interleaved arrays\n  const batch: number[][] = [batch1.slice(0, batchLength), batch2.slice(0, batchLength)];\n\n  // Modify the 2 batches\n  batch1.splice(0, batchLength);\n  batch2.splice(0, batchLength);\n  return batch;\n}\n"],"file":"zip-batch-iterators.js"}