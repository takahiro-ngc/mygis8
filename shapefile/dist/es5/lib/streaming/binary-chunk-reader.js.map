{"version":3,"sources":["../../../../src/lib/streaming/binary-chunk-reader.ts"],"names":["BinaryChunkReader","options","maxRewindBytes","offset","arrayBuffers","ended","arrayBuffer","push","bytes","bytesAvailable","byteLength","selectedBuffers","i","length","buf","start","Math","abs","end","bufferOffsets","findBufferOffsets","Error","bufferIndex","view","DataView","disposeBuffers","_combineArrayBuffers","shift","bufferOffset","result","Uint8Array","resultOffset","sourceArray","set","subarray","buffer"],"mappings":"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","sourcesContent":["export default class BinaryChunkReader {\n  offset: number;\n  arrayBuffers: ArrayBuffer[];\n  ended: boolean;\n  maxRewindBytes: number;\n\n  constructor(options?: {[key: string]: any}) {\n    const {maxRewindBytes = 0} = options || {};\n\n    /** current global offset into current array buffer*/\n    this.offset = 0;\n    /** current buffer from iterator */\n    this.arrayBuffers = [];\n    this.ended = false;\n\n    /** bytes behind offset to hold on to */\n    this.maxRewindBytes = maxRewindBytes;\n  }\n  /**\n   * @param arrayBuffer\n   */\n  write(arrayBuffer: ArrayBuffer): void {\n    this.arrayBuffers.push(arrayBuffer);\n  }\n\n  end(): void {\n    this.arrayBuffers = [];\n    this.ended = true;\n  }\n\n  /**\n   * Has enough bytes available in array buffers\n   *\n   * @param bytes Number of bytes\n   * @return boolean\n   */\n  hasAvailableBytes(bytes: number): boolean {\n    let bytesAvailable = -this.offset;\n    for (const arrayBuffer of this.arrayBuffers) {\n      bytesAvailable += arrayBuffer.byteLength;\n      if (bytesAvailable >= bytes) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Find offsets of byte ranges within this.arrayBuffers\n   *\n   * @param  bytes Byte length to read\n   * @return Arrays with byte ranges pointing to this.arrayBuffers, Output type is nested array, e.g. [ [0, [1, 2]], ...]\n   */\n  findBufferOffsets(bytes: number): any[] | null {\n    let offset = -this.offset;\n    const selectedBuffers: any = [];\n\n    for (let i = 0; i < this.arrayBuffers.length; i++) {\n      const buf = this.arrayBuffers[i];\n\n      // Current buffer isn't long enough to reach global offset\n      if (offset + buf.byteLength <= 0) {\n        offset += buf.byteLength;\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // Find start/end offsets for this buffer\n      // When offset < 0, need to skip over Math.abs(offset) bytes\n      // When offset > 0, implies bytes in previous buffer, start at 0\n      const start = offset <= 0 ? Math.abs(offset) : 0;\n      let end: number;\n\n      // Length of requested bytes is contained in current buffer\n      if (start + bytes <= buf.byteLength) {\n        end = start + bytes;\n        selectedBuffers.push([i, [start, end]]);\n        return selectedBuffers;\n      }\n\n      // Will need to look into next buffer\n      end = buf.byteLength;\n      selectedBuffers.push([i, [start, end]]);\n\n      // Need to read fewer bytes in next iter\n      bytes -= buf.byteLength - start;\n      offset += buf.byteLength;\n    }\n\n    // Should only finish loop if exhausted all arrays\n    return null;\n  }\n\n  /**\n   * Get the required number of bytes from the iterator\n   *\n   * @param bytes Number of bytes\n   * @return DataView with data\n   */\n  getDataView(bytes: number): DataView | null {\n    const bufferOffsets = this.findBufferOffsets(bytes);\n    // return `null` if not enough data, except if end() already called, in\n    // which case throw an error.\n    if (!bufferOffsets && this.ended) {\n      throw new Error('binary data exhausted');\n    }\n\n    if (!bufferOffsets) {\n      // @ts-ignore\n      return null;\n    }\n\n    // If only one arrayBuffer needed, return DataView directly\n    if (bufferOffsets.length === 1) {\n      const [bufferIndex, [start, end]] = bufferOffsets[0];\n      const arrayBuffer = this.arrayBuffers[bufferIndex];\n      const view = new DataView(arrayBuffer, start, end - start);\n\n      this.offset += bytes;\n      this.disposeBuffers();\n      return view;\n    }\n\n    // Concatenate portions of multiple ArrayBuffers\n    const view = new DataView(this._combineArrayBuffers(bufferOffsets));\n    this.offset += bytes;\n    this.disposeBuffers();\n    return view;\n  }\n\n  /**\n   * Dispose of old array buffers\n   */\n  disposeBuffers(): void {\n    while (\n      this.arrayBuffers.length > 0 &&\n      this.offset - this.maxRewindBytes >= this.arrayBuffers[0].byteLength\n    ) {\n      this.offset -= this.arrayBuffers[0].byteLength;\n      this.arrayBuffers.shift();\n    }\n  }\n\n  /**\n   * Copy multiple ArrayBuffers into one contiguous ArrayBuffer\n   *\n   * In contrast to concatenateArrayBuffers, this only copies the necessary\n   * portions of the source arrays, rather than first copying the entire arrays\n   * then taking a part of them.\n   *\n   * @param bufferOffsets List of internal array offsets\n   * @return New contiguous ArrayBuffer\n   */\n  _combineArrayBuffers(bufferOffsets: any[]): ArrayBufferLike {\n    let byteLength: number = 0;\n    for (const bufferOffset of bufferOffsets) {\n      const [start, end] = bufferOffset[1];\n      byteLength += end - start;\n    }\n\n    const result = new Uint8Array(byteLength);\n\n    // Copy the subarrays\n    let resultOffset: number = 0;\n    for (const bufferOffset of bufferOffsets) {\n      const [bufferIndex, [start, end]] = bufferOffset;\n      const sourceArray = new Uint8Array(this.arrayBuffers[bufferIndex]);\n      result.set(sourceArray.subarray(start, end), resultOffset);\n      resultOffset += end - start;\n    }\n\n    return result.buffer;\n  }\n  /**\n   * @param bytes\n   */\n  skip(bytes: number): void {\n    this.offset += bytes;\n  }\n  /**\n   * @param bytes\n   */\n  rewind(bytes: number): void {\n    // TODO - only works if offset is already set\n    this.offset -= bytes;\n  }\n}\n"],"file":"binary-chunk-reader.js"}