{"version":3,"sources":["../../../../src/lib/parsers/parse-dbf.ts"],"names":["LITTLE_ENDIAN","DBF_HEADER_SIZE","STATE","DBFParser","options","BinaryChunkReader","START","data","textDecoder","TextDecoder","encoding","arrayBuffer","binaryReader","write","state","parseState","result","end","END","ERROR","error","parseDBF","loaderOptions","dbf","dbfParser","schema","tables","format","rows","parseDBFInBatches","asyncIterator","parser","headerReturned","dbfHeader","length","dataView","getDataView","parseDBFHeader","progress","bytesUsed","rowsTotal","nRecords","FIELD_DESCRIPTORS","fieldDescriptorView","headerLength","dbfFields","parseFieldDescriptors","Schema","map","dbfField","makeField","FIELD_PROPERTIES","skip","recordLength","recordView","row","parseRow","push","message","headerView","year","getUint8","month","day","getUint32","getUint16","languageDriver","view","nFields","byteLength","fields","offset","i","name","decode","Uint8Array","buffer","byteOffset","replace","dataType","String","fromCharCode","fieldLength","decimal","out","field","text","parseField","parseNumber","parseCharacter","parseDate","parseBoolean","Error","str","Date","UTC","slice","parseInt","value","test","number","parseFloat","isNaN","trim","Field","Float64","Utf8","TimestampMillisecond","Bool"],"mappings":"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","sourcesContent":["import {Schema, Field, Bool, Utf8, Float64, TimestampMillisecond} from '@loaders.gl/schema';\nimport BinaryChunkReader from '../streaming/binary-chunk-reader';\n\ntype DBFRowsOutput = object[];\n\ninterface DBFTableOutput {\n  schema?: Schema;\n  rows: DBFRowsOutput;\n}\n\ntype DBFHeader = {\n  // Last updated date\n  year: number;\n  month: number;\n  day: number;\n  // Number of records in data file\n  nRecords: number;\n  // Length of header in bytes\n  headerLength: number;\n  // Length of each record\n  recordLength: number;\n  // Not sure if this is usually set\n  languageDriver: number;\n};\n\ntype DBFField = {\n  name: string;\n  dataType: string;\n  fieldLength: number;\n  decimal: number;\n};\n\ntype DBFResult = {\n  data: {[key: string]: any}[];\n  schema?: Schema;\n  error?: string;\n  dbfHeader?: DBFHeader;\n  dbfFields?: DBFField[];\n  progress?: {\n    bytesUsed: number;\n    rowsTotal: number;\n    rows: number;\n  };\n};\n\nconst LITTLE_ENDIAN = true;\nconst DBF_HEADER_SIZE = 32;\n\nenum STATE {\n  START = 0, // Expecting header\n  FIELD_DESCRIPTORS = 1,\n  FIELD_PROPERTIES = 2,\n  END = 3,\n  ERROR = 4\n}\n\nclass DBFParser {\n  binaryReader = new BinaryChunkReader();\n  textDecoder: TextDecoder;\n  state = STATE.START;\n  result: DBFResult = {\n    data: []\n  };\n\n  constructor(options: {encoding: string}) {\n    this.textDecoder = new TextDecoder(options.encoding);\n  }\n\n  /**\n   * @param arrayBuffer\n   */\n  write(arrayBuffer: ArrayBuffer): void {\n    this.binaryReader.write(arrayBuffer);\n    this.state = parseState(this.state, this.result, this.binaryReader, this.textDecoder);\n    // this.result.progress.bytesUsed = this.binaryReader.bytesUsed();\n\n    // important events:\n    // - schema available\n    // - first rows available\n    // - all rows available\n  }\n\n  end(): void {\n    this.binaryReader.end();\n    this.state = parseState(this.state, this.result, this.binaryReader, this.textDecoder);\n    // this.result.progress.bytesUsed = this.binaryReader.bytesUsed();\n    if (this.state !== STATE.END) {\n      this.state = STATE.ERROR;\n      this.result.error = 'DBF incomplete file';\n    }\n  }\n}\n\n/**\n * @param arrayBuffer\n * @param options\n * @returns DBFTable or rows\n */\nexport function parseDBF(\n  arrayBuffer: ArrayBuffer,\n  options: any = {}\n): DBFRowsOutput | DBFTableOutput {\n  const loaderOptions = options.dbf || {};\n  const {encoding} = loaderOptions;\n\n  const dbfParser = new DBFParser({encoding});\n  dbfParser.write(arrayBuffer);\n  dbfParser.end();\n\n  const {data, schema} = dbfParser.result;\n  switch (options.tables && options.tables.format) {\n    case 'table':\n      // TODO - parse columns\n      return {schema, rows: data};\n\n    case 'rows':\n    default:\n      return data;\n  }\n}\n/**\n * @param asyncIterator\n * @param options\n */\nexport async function* parseDBFInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: any = {}\n): AsyncIterable<DBFHeader | DBFRowsOutput | DBFTableOutput> {\n  const loaderOptions = options.dbf || {};\n  const {encoding} = loaderOptions;\n\n  const parser = new DBFParser({encoding});\n  let headerReturned = false;\n  for await (const arrayBuffer of asyncIterator) {\n    parser.write(arrayBuffer);\n    if (!headerReturned && parser.result.dbfHeader) {\n      headerReturned = true;\n      yield parser.result.dbfHeader;\n    }\n\n    if (parser.result.data.length > 0) {\n      yield parser.result.data;\n      parser.result.data = [];\n    }\n  }\n  parser.end();\n  if (parser.result.data.length > 0) {\n    yield parser.result.data;\n  }\n}\n/**\n * https://www.dbase.com/Knowledgebase/INT/db7_file_fmt.htm\n * @param state\n * @param result\n * @param binaryReader\n * @param textDecoder\n * @returns\n */\n/* eslint-disable complexity, max-depth */\nfunction parseState(\n  state: STATE,\n  result: DBFResult,\n  binaryReader: {[key: string]: any},\n  textDecoder: TextDecoder\n): STATE {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    try {\n      switch (state) {\n        case STATE.ERROR:\n        case STATE.END:\n          return state;\n\n        case STATE.START:\n          // Parse initial file header\n          const dataView = binaryReader.getDataView(DBF_HEADER_SIZE, 'DBF header');\n          if (!dataView) {\n            return state;\n          }\n          result.dbfHeader = parseDBFHeader(dataView);\n          result.progress = {\n            bytesUsed: 0,\n            rowsTotal: result.dbfHeader.nRecords,\n            rows: 0\n          };\n          state = STATE.FIELD_DESCRIPTORS;\n          break;\n\n        case STATE.FIELD_DESCRIPTORS:\n          // Parse DBF field descriptors (schema)\n          const fieldDescriptorView = binaryReader.getDataView(\n            // @ts-ignore\n            result.dbfHeader.headerLength - DBF_HEADER_SIZE,\n            'DBF field descriptors'\n          );\n          if (!fieldDescriptorView) {\n            return state;\n          }\n\n          result.dbfFields = parseFieldDescriptors(fieldDescriptorView, textDecoder);\n          result.schema = new Schema(result.dbfFields.map((dbfField) => makeField(dbfField)));\n\n          state = STATE.FIELD_PROPERTIES;\n\n          // TODO(kyle) Not exactly sure why start offset needs to be headerLength + 1?\n          // parsedbf uses ((fields.length + 1) << 5) + 2;\n          binaryReader.skip(1);\n          break;\n\n        case STATE.FIELD_PROPERTIES:\n          const {recordLength = 0, nRecords = 0} = result?.dbfHeader || {};\n          while (result.data.length < nRecords) {\n            const recordView = binaryReader.getDataView(recordLength - 1);\n            if (!recordView) {\n              return state;\n            }\n            // Note: Avoid actually reading the last byte, which may not be present\n            binaryReader.skip(1);\n\n            // @ts-ignore\n            const row = parseRow(recordView, result.dbfFields, textDecoder);\n            result.data.push(row);\n            // @ts-ignore\n            result.progress.rows = result.data.length;\n          }\n          state = STATE.END;\n          break;\n\n        default:\n          state = STATE.ERROR;\n          result.error = `illegal parser state ${state}`;\n          return state;\n      }\n    } catch (error) {\n      state = STATE.ERROR;\n      result.error = `DBF parsing failed: ${(error as Error).message}`;\n      return state;\n    }\n  }\n}\n\n/**\n * @param headerView\n */\nfunction parseDBFHeader(headerView: DataView): DBFHeader {\n  return {\n    // Last updated date\n    year: headerView.getUint8(1) + 1900,\n    month: headerView.getUint8(2),\n    day: headerView.getUint8(3),\n    // Number of records in data file\n    nRecords: headerView.getUint32(4, LITTLE_ENDIAN),\n    // Length of header in bytes\n    headerLength: headerView.getUint16(8, LITTLE_ENDIAN),\n    // Length of each record\n    recordLength: headerView.getUint16(10, LITTLE_ENDIAN),\n    // Not sure if this is usually set\n    languageDriver: headerView.getUint8(29)\n  };\n}\n\n/**\n * @param view\n */\nfunction parseFieldDescriptors(view: DataView, textDecoder: TextDecoder): DBFField[] {\n  // NOTE: this might overestimate the number of fields if the \"Database\n  // Container\" container exists and is included in the headerLength\n  const nFields = (view.byteLength - 1) / 32;\n  const fields: DBFField[] = [];\n  let offset = 0;\n  for (let i = 0; i < nFields; i++) {\n    const name = textDecoder\n      .decode(new Uint8Array(view.buffer, view.byteOffset + offset, 11))\n      // eslint-disable-next-line no-control-regex\n      .replace(/\\u0000/g, '');\n\n    fields.push({\n      name,\n      dataType: String.fromCharCode(view.getUint8(offset + 11)),\n      fieldLength: view.getUint8(offset + 16),\n      decimal: view.getUint8(offset + 17)\n    });\n    offset += 32;\n  }\n  return fields;\n}\n\n/*\n * @param {BinaryChunkReader} binaryReader\nfunction parseRows(binaryReader, fields, nRecords, recordLength, textDecoder) {\n  const rows = [];\n  for (let i = 0; i < nRecords; i++) {\n    const recordView = binaryReader.getDataView(recordLength - 1);\n    binaryReader.skip(1);\n    // @ts-ignore\n    rows.push(parseRow(recordView, fields, textDecoder));\n  }\n  return rows;\n}\n */\n\n/**\n *\n * @param view\n * @param fields\n * @param textDecoder\n * @returns\n */\nfunction parseRow(\n  view: DataView,\n  fields: DBFField[],\n  textDecoder: TextDecoder\n): {[key: string]: any} {\n  const out = {};\n  let offset = 0;\n  for (const field of fields) {\n    const text = textDecoder.decode(\n      new Uint8Array(view.buffer, view.byteOffset + offset, field.fieldLength)\n    );\n    out[field.name] = parseField(text, field.dataType);\n    offset += field.fieldLength;\n  }\n\n  return out;\n}\n\n/**\n * Should NaN be coerced to null?\n * @param text\n * @param dataType\n * @returns Field depends on a type of the data\n */\nfunction parseField(text: string, dataType: string): string | number | boolean | null {\n  switch (dataType) {\n    case 'B':\n      return parseNumber(text);\n    case 'C':\n      return parseCharacter(text);\n    case 'F':\n      return parseNumber(text);\n    case 'N':\n      return parseNumber(text);\n    case 'O':\n      return parseNumber(text);\n    case 'D':\n      return parseDate(text);\n    case 'L':\n      return parseBoolean(text);\n    default:\n      throw new Error('Unsupported data type');\n  }\n}\n\n/**\n * Parse YYYYMMDD to date in milliseconds\n * @param str YYYYMMDD\n * @returns new Date as a number\n */\nfunction parseDate(str: any): number {\n  return Date.UTC(str.slice(0, 4), parseInt(str.slice(4, 6), 10) - 1, str.slice(6, 8));\n}\n\n/**\n * Read boolean value\n * any of Y, y, T, t coerce to true\n * any of N, n, F, f coerce to false\n * otherwise null\n * @param value\n * @returns boolean | null\n */\nfunction parseBoolean(value: string): boolean | null {\n  return /^[nf]$/i.test(value) ? false : /^[yt]$/i.test(value) ? true : null;\n}\n\n/**\n * Return null instead of NaN\n * @param text\n * @returns number | null\n */\nfunction parseNumber(text: string): number | null {\n  const number = parseFloat(text);\n  return isNaN(number) ? null : number;\n}\n\n/**\n *\n * @param text\n * @returns string | null\n */\nfunction parseCharacter(text: string): string | null {\n  return text.trim() || null;\n}\n\n/**\n * Create a standard Arrow-style `Field` from field descriptor.\n * TODO - use `fieldLength` and `decimal` to generate smaller types?\n * @param param0\n * @returns Field\n */\n// eslint-disable\nfunction makeField({name, dataType, fieldLength, decimal}): Field {\n  switch (dataType) {\n    case 'B':\n      return new Field(name, new Float64(), true);\n    case 'C':\n      return new Field(name, new Utf8(), true);\n    case 'F':\n      return new Field(name, new Float64(), true);\n    case 'N':\n      return new Field(name, new Float64(), true);\n    case 'O':\n      return new Field(name, new Float64(), true);\n    case 'D':\n      return new Field(name, new TimestampMillisecond(), true);\n    case 'L':\n      return new Field(name, new Bool(), true);\n    default:\n      throw new Error('Unsupported data type');\n  }\n}\n"],"file":"parse-dbf.js"}