{"version":3,"sources":["../../../../src/lib/parsers/parse-shp.ts"],"names":["LITTLE_ENDIAN","BIG_ENDIAN","SHP_HEADER_SIZE","SHP_RECORD_HEADER_SIZE","STATE","EXPECTING_HEADER","EXPECTING_RECORD","END","ERROR","SHPParser","options","BinaryChunkReader","maxRewindBytes","geometries","arrayBuffer","binaryReader","write","state","parseState","result","end","error","parseSHP","shpParser","parseSHPInBatches","asyncIterator","parser","headerReturned","header","length","dataView","getDataView","progress","bytesUsed","bytesTotal","rows","currentIndex","hasAvailableBytes","recordHeaderView","recordHeader","recordNumber","getInt32","byteLength","type","rewind","invalidRecord","recordView","geometry","push","ended","message"],"mappings":"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","sourcesContent":["import type {LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {BinaryGeometry} from '@loaders.gl/schema';\nimport BinaryChunkReader from '../streaming/binary-chunk-reader';\nimport {parseSHPHeader} from './parse-shp-header';\nimport {parseRecord} from './parse-shp-geometry';\n\nconst LITTLE_ENDIAN = true;\nconst BIG_ENDIAN = false;\n\nconst SHP_HEADER_SIZE = 100;\n// According to the spec, the record header is just 8 bytes, but here we set it\n// to 12 so that we can also access the record's type\nconst SHP_RECORD_HEADER_SIZE = 12;\n\nconst STATE = {\n  EXPECTING_HEADER: 0,\n  EXPECTING_RECORD: 1,\n  END: 2,\n  ERROR: 3\n};\n\ntype SHPResult = {\n  geometries: [];\n  header?: {};\n  error?: string;\n};\n\nclass SHPParser {\n  options?: any = {};\n  binaryReader = new BinaryChunkReader({maxRewindBytes: SHP_RECORD_HEADER_SIZE});\n  state = STATE.EXPECTING_HEADER;\n  result: SHPResult = {\n    geometries: []\n  };\n\n  constructor(options?: LoaderOptions) {\n    this.options = options;\n  }\n\n  write(arrayBuffer: ArrayBuffer) {\n    this.binaryReader.write(arrayBuffer);\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n  }\n\n  end() {\n    this.binaryReader.end();\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n    // this.result.progress.bytesUsed = this.binaryReader.bytesUsed();\n    if (this.state !== STATE.END) {\n      this.state = STATE.ERROR;\n      this.result.error = 'SHP incomplete file';\n    }\n  }\n}\n\nexport function parseSHP(arrayBuffer: ArrayBuffer, options?: object): BinaryGeometry[] {\n  const shpParser = new SHPParser(options);\n  shpParser.write(arrayBuffer);\n  shpParser.end();\n\n  // @ts-ignore\n  return shpParser.result;\n}\n\n/**\n * @param asyncIterator\n * @param options\n * @returns\n */\nexport async function* parseSHPInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: object\n): AsyncIterable<BinaryGeometry | object> {\n  const parser = new SHPParser(options);\n  let headerReturned = false;\n  for await (const arrayBuffer of asyncIterator) {\n    parser.write(arrayBuffer);\n    if (!headerReturned && parser.result.header) {\n      headerReturned = true;\n      yield parser.result.header;\n    }\n\n    if (parser.result.geometries.length > 0) {\n      yield parser.result.geometries;\n      parser.result.geometries = [];\n    }\n  }\n  parser.end();\n  if (parser.result.geometries.length > 0) {\n    yield parser.result.geometries;\n  }\n\n  return;\n}\n\n/**\n * State-machine parser for SHP data\n *\n * Note that whenever more data is needed, a `return`, not a `break`, is\n * necessary, as the `break` keeps the context within `parseState`, while\n * `return` releases context so that more data can be written into the\n * BinaryChunkReader.\n *\n * @param  state Current state\n * @param  result An object to hold result data\n * @param  binaryReader\n * @return State at end of current parsing\n */\n/* eslint-disable complexity, max-depth */\nfunction parseState(\n  state: number,\n  result: {[key: string]: any},\n  binaryReader: BinaryChunkReader,\n  options: {shp?: any}\n): number {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    try {\n      switch (state) {\n        case STATE.ERROR:\n        case STATE.END:\n          return state;\n\n        case STATE.EXPECTING_HEADER:\n          // Parse initial file header\n          const dataView = binaryReader.getDataView(SHP_HEADER_SIZE);\n          if (!dataView) {\n            return state;\n          }\n\n          result.header = parseSHPHeader(dataView);\n          result.progress = {\n            bytesUsed: 0,\n            bytesTotal: result.header.length,\n            rows: 0\n          };\n          // index numbering starts at 1\n          result.currentIndex = 1;\n          state = STATE.EXPECTING_RECORD;\n          break;\n\n        case STATE.EXPECTING_RECORD:\n          while (binaryReader.hasAvailableBytes(SHP_RECORD_HEADER_SIZE)) {\n            const recordHeaderView = binaryReader.getDataView(SHP_RECORD_HEADER_SIZE) as DataView;\n            const recordHeader = {\n              recordNumber: recordHeaderView.getInt32(0, BIG_ENDIAN),\n              // 2 byte words; includes the four words of record header\n              byteLength: recordHeaderView.getInt32(4, BIG_ENDIAN) * 2,\n              // This is actually part of the record, not the header...\n              type: recordHeaderView.getInt32(8, LITTLE_ENDIAN)\n            };\n\n            if (!binaryReader.hasAvailableBytes(recordHeader.byteLength - 4)) {\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE);\n              return state;\n            }\n\n            const invalidRecord =\n              recordHeader.byteLength < 4 ||\n              recordHeader.type !== result.header.type ||\n              recordHeader.recordNumber !== result.currentIndex;\n\n            // All records must have at least four bytes (for the record shape type)\n            if (invalidRecord) {\n              // Malformed record, try again, advancing just 4 bytes\n              // Note: this is a rewind because binaryReader.getDataView above\n              // moved the pointer forward 12 bytes, so rewinding 8 bytes still\n              // leaves us 4 bytes ahead\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE - 4);\n            } else {\n              // Note: type is actually part of the record, not the header, so\n              // rewind 4 bytes before reading record\n              binaryReader.rewind(4);\n\n              const recordView = binaryReader.getDataView(recordHeader.byteLength) as DataView;\n              const geometry = parseRecord(recordView, options);\n              result.geometries.push(geometry);\n\n              result.currentIndex++;\n              result.progress.rows = result.currentIndex - 1;\n            }\n          }\n\n          if (binaryReader.ended) {\n            state = STATE.END;\n          }\n\n          return state;\n\n        default:\n          state = STATE.ERROR;\n          result.error = `illegal parser state ${state}`;\n          return state;\n      }\n    } catch (error) {\n      state = STATE.ERROR;\n      result.error = `SHP parsing failed: ${(error as Error)?.message}`;\n      return state;\n    }\n  }\n}\n"],"file":"parse-shp.js"}