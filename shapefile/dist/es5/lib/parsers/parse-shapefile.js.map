{"version":3,"sources":["../../../../src/lib/parsers/parse-shapefile.ts"],"names":["parseShapefileInBatches","asyncIterator","options","context","gis","reproject","_targetCrs","loadShapefileSidecarFiles","shx","cpg","prj","parseInBatches","SHPLoader","shapeIterable","fetch","replaceExtension","url","dbfResponse","ok","DBFLoader","dbf","encoding","propertyIterable","next","shapeHeader","value","batchType","dbfHeader","iterator","item","geometries","properties","geojsonGeometries","parseGeometries","features","joinProperties","reprojectFeatures","header","data","parseShapefile","arrayBuffer","parse","geom","push","i","length","geometry","feature","type","sourceCrs","targetCrs","projection","Proj4Projection","from","to","coord","project","shxPromise","cpgPromise","prjPromise","Promise","all","shxResponse","cpgResponse","text","prjResponse","newExtension","baseName","basename","extension","extname","isUpperCase","toUpperCase","extIndex","lastIndexOf","substr"],"mappings":"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","sourcesContent":["// import type {Feature} from '@loaders.gl/gis';\nimport type {SHXOutput} from './parse-shx';\nimport type {SHPHeader} from './parse-shp-header';\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\n\nimport {binaryToGeometry, transformGeoJsonCoords} from '@loaders.gl/gis';\nimport {Proj4Projection} from '@math.gl/proj4';\nimport {parseShx} from './parse-shx';\nimport {zipBatchIterators} from '../streaming/zip-batch-iterators';\nimport {SHPLoader} from '../../shp-loader';\nimport {DBFLoader} from '../../dbf-loader';\n\ntype Feature = any;\ninterface ShapefileOutput {\n  encoding?: string;\n  prj?: string;\n  shx?: SHXOutput;\n  header: SHPHeader;\n  data: object[];\n}\n/**\n * Parsing of file in batches\n *\n * @param asyncIterator\n * @param options\n * @param context\n */\n// eslint-disable-next-line max-statements, complexity\nexport async function* parseShapefileInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: any,\n  context?: LoaderContext\n): AsyncIterable<ShapefileOutput> {\n  const {reproject = false, _targetCrs = 'WGS84'} = options?.gis || {};\n  const {shx, cpg, prj} = await loadShapefileSidecarFiles(options, context);\n\n  // parse geometries\n  // @ts-ignore context must be defined\n  const shapeIterable: any = await context.parseInBatches(asyncIterator, SHPLoader, options);\n\n  // parse properties\n  let propertyIterable: any;\n  // @ts-ignore context must be defined\n  const dbfResponse = await context.fetch(replaceExtension(context?.url || '', 'dbf'));\n  if (dbfResponse.ok) {\n    // @ts-ignore context must be defined\n    propertyIterable = await context.parseInBatches(dbfResponse, DBFLoader, {\n      ...options,\n      dbf: {encoding: cpg || 'latin1'}\n    });\n  }\n\n  // When `options.metadata` is `true`, there's an extra initial `metadata`\n  // object before the iterator starts. zipBatchIterators expects to receive\n  // batches of Array objects, and will fail with non-iterable batches, so it's\n  // important to skip over the first batch.\n  let shapeHeader = (await shapeIterable.next()).value;\n  if (shapeHeader && shapeHeader.batchType === 'metadata') {\n    shapeHeader = (await shapeIterable.next()).value;\n  }\n\n  let dbfHeader: {batchType?: string} = {};\n  if (propertyIterable) {\n    dbfHeader = (await propertyIterable.next()).value;\n    if (dbfHeader && dbfHeader.batchType === 'metadata') {\n      dbfHeader = (await propertyIterable.next()).value;\n    }\n  }\n\n  let iterator: any;\n  if (propertyIterable) {\n    iterator = zipBatchIterators(shapeIterable, propertyIterable);\n  } else {\n    iterator = shapeIterable;\n  }\n\n  for await (const item of iterator) {\n    let geometries: any;\n    let properties: any;\n    if (!propertyIterable) {\n      geometries = item;\n    } else {\n      [geometries, properties] = item;\n    }\n\n    const geojsonGeometries = parseGeometries(geometries);\n    let features = joinProperties(geojsonGeometries, properties);\n    if (reproject) {\n      // @ts-ignore\n      features = reprojectFeatures(features, prj, _targetCrs);\n    }\n    yield {\n      encoding: cpg,\n      prj,\n      shx,\n      header: shapeHeader,\n      data: features\n    };\n  }\n}\n\n/**\n * Parse shapefile\n *\n * @param arrayBuffer\n * @param options\n * @param context\n * @returns output of shapefile\n */\nexport async function parseShapefile(\n  arrayBuffer: ArrayBuffer,\n  options?: {[key: string]: any},\n  context?: LoaderContext\n): Promise<ShapefileOutput> {\n  const {reproject = false, _targetCrs = 'WGS84'} = options?.gis || {};\n  const {shx, cpg, prj} = await loadShapefileSidecarFiles(options, context);\n\n  // parse geometries\n  // @ts-ignore context must be defined\n  const {header, geometries} = await context.parse(arrayBuffer, SHPLoader, options); // {shp: shx}\n\n  const geojsonGeometries = parseGeometries(geometries);\n\n  // parse properties\n  let properties = [];\n\n  // @ts-ignore context must be defined\n  const dbfResponse = await context.fetch(replaceExtension(context.url, 'dbf'));\n  if (dbfResponse.ok) {\n    // @ts-ignore context must be defined\n    properties = await context.parse(dbfResponse, DBFLoader, {dbf: {encoding: cpg || 'latin1'}});\n  }\n\n  let features = joinProperties(geojsonGeometries, properties);\n  if (reproject) {\n    features = reprojectFeatures(features, prj, _targetCrs);\n  }\n\n  return {\n    encoding: cpg,\n    prj,\n    shx,\n    header,\n    data: features\n  };\n}\n\n/**\n * Parse geometries\n *\n * @param geometries\n * @returns geometries as an array\n */\nfunction parseGeometries(geometries: any[]): any[] {\n  const geojsonGeometries: any[] = [];\n  for (const geom of geometries) {\n    geojsonGeometries.push(binaryToGeometry(geom));\n  }\n  return geojsonGeometries;\n}\n\n/**\n * Join properties and geometries into features\n *\n * @param geometries [description]\n * @param  properties [description]\n * @return [description]\n */\nfunction joinProperties(geometries: object[], properties: object[]): Feature[] {\n  const features: Feature[] = [];\n  for (let i = 0; i < geometries.length; i++) {\n    const geometry = geometries[i];\n    const feature: Feature = {\n      type: 'Feature',\n      geometry,\n      // properties can be undefined if dbfResponse above was empty\n      properties: (properties && properties[i]) || {}\n    };\n    features.push(feature);\n  }\n\n  return features;\n}\n\n/**\n * Reproject GeoJSON features to output CRS\n *\n * @param features parsed GeoJSON features\n * @param sourceCrs source coordinate reference system\n * @param targetCrs †arget coordinate reference system\n * @return Reprojected Features\n */\nfunction reprojectFeatures(features: Feature[], sourceCrs?: string, targetCrs?: string): Feature[] {\n  if (!sourceCrs && !targetCrs) {\n    return features;\n  }\n\n  const projection = new Proj4Projection({from: sourceCrs || 'WGS84', to: targetCrs || 'WGS84'});\n  return transformGeoJsonCoords(features, (coord) => projection.project(coord));\n}\n\n/**\n *\n * @param options\n * @param context\n * @returns Promise\n */\n// eslint-disable-next-line max-statements\nexport async function loadShapefileSidecarFiles(\n  options?: object,\n  context?: LoaderContext\n): Promise<{\n  shx?: SHXOutput;\n  cpg?: string;\n  prj?: string;\n}> {\n  // Attempt a parallel load of the small sidecar files\n  // @ts-ignore context must be defined\n  const {url, fetch} = context;\n  const shxPromise = fetch(replaceExtension(url, 'shx'));\n  const cpgPromise = fetch(replaceExtension(url, 'cpg'));\n  const prjPromise = fetch(replaceExtension(url, 'prj'));\n  await Promise.all([shxPromise, cpgPromise, prjPromise]);\n\n  let shx: SHXOutput | undefined;\n  let cpg: string | undefined;\n  let prj: string | undefined;\n\n  const shxResponse = await shxPromise;\n  if (shxResponse.ok) {\n    const arrayBuffer = await shxResponse.arrayBuffer();\n    shx = parseShx(arrayBuffer);\n  }\n\n  const cpgResponse = await cpgPromise;\n  if (cpgResponse.ok) {\n    cpg = await cpgResponse.text();\n  }\n\n  const prjResponse = await prjPromise;\n  if (prjResponse.ok) {\n    prj = await prjResponse.text();\n  }\n\n  return {\n    shx,\n    cpg,\n    prj\n  };\n}\n\n/**\n * Replace the extension at the end of a path.\n *\n * Matches the case of new extension with the case of the original file extension,\n * to increase the chance of finding files without firing off a request storm looking for various case combinations\n *\n * NOTE: Extensions can be both lower and uppercase\n * per spec, extensions should be lower case, but that doesn't mean they always are. See:\n * calvinmetcalf/shapefile-js#64, mapserver/mapserver#4712\n * https://trac.osgeo.org/mapserver/ticket/166\n */\nexport function replaceExtension(url: string, newExtension: string): string {\n  const baseName = basename(url);\n  const extension = extname(url);\n  const isUpperCase = extension === extension.toUpperCase();\n  if (isUpperCase) {\n    newExtension = newExtension.toUpperCase();\n  }\n  return `${baseName}.${newExtension}`;\n}\n\n// NOTE - this gives the entire path minus extension (i.e. NOT same as path.basename)\n/**\n * @param url\n * @returns string\n */\nfunction basename(url: string): string {\n  const extIndex = url && url.lastIndexOf('.');\n  if (typeof extIndex === 'number') {\n    return extIndex >= 0 ? url.substr(0, extIndex) : '';\n  }\n  return extIndex;\n}\n/**\n * @param url\n * @returns string\n */\nfunction extname(url: string): string {\n  const extIndex = url && url.lastIndexOf('.');\n  if (typeof extIndex === 'number') {\n    return extIndex >= 0 ? url.substr(extIndex + 1) : '';\n  }\n  return extIndex;\n}\n"],"file":"parse-shapefile.js"}