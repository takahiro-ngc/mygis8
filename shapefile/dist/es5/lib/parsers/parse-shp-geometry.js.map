{"version":3,"sources":["../../../../src/lib/parsers/parse-shp-geometry.ts"],"names":["LITTLE_ENDIAN","parseRecord","view","options","shp","_maxDimensions","offset","type","getInt32","Int32Array","BYTES_PER_ELEMENT","parseNull","parsePoint","Math","min","parsePoly","parseMultiPoint","Error","dim","positions","parsePositions","value","size","Float64Array","nPoints","xyPositions","mPositions","zPositions","concatPositions","nParts","bufferOffset","byteOffset","bufferLength","ringIndices","set","buffer","slice","pathIndices","polygonIndices","i","length","startRingIndex","endRingIndex","ring","subarray","sign","getWindingDirection","push","primitivePolygonIndices","Uint32Array","arrayLength","nDim","getSignedArea","area","nCoords"],"mappings":";;;;;;;;;;;AAEA,IAAMA,aAAa,GAAG,IAAtB;;AASO,SAASC,WAAT,CAAqBC,IAArB,EAAqCC,OAArC,EAAmF;AACxF,aAAyB,CAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEC,GAAT,KAAgB,EAAzC;AAAA,MAAOC,cAAP,QAAOA,cAAP;;AAEA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAMC,IAAY,GAAGL,IAAI,CAACM,QAAL,CAAcF,MAAd,EAAsBN,aAAtB,CAArB;AACAM,EAAAA,MAAM,IAAIG,UAAU,CAACC,iBAArB;;AAEA,UAAQH,IAAR;AACE,SAAK,CAAL;AAEE,aAAOI,SAAS,EAAhB;;AACF,SAAK,CAAL;AAEE,aAAOC,UAAU,CAACV,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,CAAjB;;AACF,SAAK,CAAL;AAEE,aAAOU,SAAS,CAACb,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,EAA4C,YAA5C,CAAhB;;AACF,SAAK,CAAL;AAEE,aAAOU,SAAS,CAACb,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,EAA4C,SAA5C,CAAhB;;AACF,SAAK,CAAL;AAEE,aAAOW,eAAe,CAACd,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,CAAtB;;AAGF,SAAK,EAAL;AAEE,aAAOO,UAAU,CAACV,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,CAAjB;;AACF,SAAK,EAAL;AAEE,aAAOU,SAAS,CAACb,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,EAA4C,YAA5C,CAAhB;;AACF,SAAK,EAAL;AAEE,aAAOU,SAAS,CAACb,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,EAA4C,SAA5C,CAAhB;;AACF,SAAK,EAAL;AAEE,aAAOW,eAAe,CAACd,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,CAAtB;;AACF,SAAK,EAAL;AAEE,aAAOO,UAAU,CAACV,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,CAAjB;;AACF,SAAK,EAAL;AAEE,aAAOU,SAAS,CAACb,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,EAA4C,YAA5C,CAAhB;;AACF,SAAK,EAAL;AAEE,aAAOU,SAAS,CAACb,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,EAA4C,SAA5C,CAAhB;;AACF,SAAK,EAAL;AAEE,aAAOW,eAAe,CAACd,IAAD,EAAOI,MAAP,EAAeO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,cAAZ,CAAf,CAAtB;;AACF;AACE,YAAM,IAAIY,KAAJ,mCAAqCV,IAArC,EAAN;AA3CJ;AA6CD;;AAQD,SAASI,SAAT,GAA2B;AACzB,SAAO,IAAP;AACD;;AASD,SAASC,UAAT,CAAoBV,IAApB,EAAoCI,MAApC,EAAoDY,GAApD,EAAiF;AAC/E,MAAIC,SAAJ;;AAD+E,wBAEzDC,cAAc,CAAClB,IAAD,EAAOI,MAAP,EAAe,CAAf,EAAkBY,GAAlB,CAF2C;;AAAA;;AAE9EC,EAAAA,SAF8E;AAEnEb,EAAAA,MAFmE;AAI/E,SAAO;AACLa,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAEF,SAAR;AAAmBG,MAAAA,IAAI,EAAEJ;AAAzB,KADN;AAELX,IAAAA,IAAI,EAAE;AAFD,GAAP;AAID;;AAUD,SAASS,eAAT,CAAyBd,IAAzB,EAAyCI,MAAzC,EAAyDY,GAAzD,EAAsF;AAEpFZ,EAAAA,MAAM,IAAI,IAAIiB,YAAY,CAACb,iBAA3B;AAEA,MAAMc,OAAO,GAAGtB,IAAI,CAACM,QAAL,CAAcF,MAAd,EAAsBN,aAAtB,CAAhB;AACAM,EAAAA,MAAM,IAAIG,UAAU,CAACC,iBAArB;AAEA,MAAIe,WAAgC,GAAG,IAAvC;AACA,MAAIC,UAA+B,GAAG,IAAtC;AACA,MAAIC,UAA+B,GAAG,IAAtC;;AAToF,yBAU5DP,cAAc,CAAClB,IAAD,EAAOI,MAAP,EAAekB,OAAf,EAAwB,CAAxB,CAV8C;;AAAA;;AAUnFC,EAAAA,WAVmF;AAUtEnB,EAAAA,MAVsE;;AAapF,MAAIY,GAAG,KAAK,CAAZ,EAAe;AAEbZ,IAAAA,MAAM,IAAI,IAAIiB,YAAY,CAACb,iBAA3B;;AAFa,2BAGUU,cAAc,CAAClB,IAAD,EAAOI,MAAP,EAAekB,OAAf,EAAwB,CAAxB,CAHxB;;AAAA;;AAGZG,IAAAA,UAHY;AAGArB,IAAAA,MAHA;AAId;;AAGD,MAAIY,GAAG,IAAI,CAAX,EAAc;AAEZZ,IAAAA,MAAM,IAAI,IAAIiB,YAAY,CAACb,iBAA3B;;AAFY,2BAGWU,cAAc,CAAClB,IAAD,EAAOI,MAAP,EAAekB,OAAf,EAAwB,CAAxB,CAHzB;;AAAA;;AAGXE,IAAAA,UAHW;AAGCpB,IAAAA,MAHD;AAIb;;AAED,MAAMa,SAAS,GAAGS,eAAe,CAACH,WAAD,EAAcC,UAAd,EAA0BC,UAA1B,CAAjC;AAEA,SAAO;AACLR,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAEF,SAAR;AAAmBG,MAAAA,IAAI,EAAEJ;AAAzB,KADN;AAELX,IAAAA,IAAI,EAAE;AAFD,GAAP;AAID;;AAYD,SAASQ,SAAT,CACEb,IADF,EAEEI,MAFF,EAGEY,GAHF,EAIEX,IAJF,EAKkB;AAEhBD,EAAAA,MAAM,IAAI,IAAIiB,YAAY,CAACb,iBAA3B;AAEA,MAAMmB,MAAM,GAAG3B,IAAI,CAACM,QAAL,CAAcF,MAAd,EAAsBN,aAAtB,CAAf;AACAM,EAAAA,MAAM,IAAIG,UAAU,CAACC,iBAArB;AACA,MAAMc,OAAO,GAAGtB,IAAI,CAACM,QAAL,CAAcF,MAAd,EAAsBN,aAAtB,CAAhB;AACAM,EAAAA,MAAM,IAAIG,UAAU,CAACC,iBAArB;AAIA,MAAMoB,YAAY,GAAG5B,IAAI,CAAC6B,UAAL,GAAkBzB,MAAvC;AACA,MAAM0B,YAAY,GAAGH,MAAM,GAAGpB,UAAU,CAACC,iBAAzC;AACA,MAAMuB,WAAW,GAAG,IAAIxB,UAAJ,CAAeoB,MAAM,GAAG,CAAxB,CAApB;AACAI,EAAAA,WAAW,CAACC,GAAZ,CAAgB,IAAIzB,UAAJ,CAAeP,IAAI,CAACiC,MAAL,CAAYC,KAAZ,CAAkBN,YAAlB,EAAgCA,YAAY,GAAGE,YAA/C,CAAf,CAAhB;AACAC,EAAAA,WAAW,CAACJ,MAAD,CAAX,GAAsBL,OAAtB;AACAlB,EAAAA,MAAM,IAAIuB,MAAM,GAAGpB,UAAU,CAACC,iBAA9B;AAEA,MAAIe,WAAgC,GAAG,IAAvC;AACA,MAAIC,UAA+B,GAAG,IAAtC;AACA,MAAIC,UAA+B,GAAG,IAAtC;;AApBgB,yBAqBQP,cAAc,CAAClB,IAAD,EAAOI,MAAP,EAAekB,OAAf,EAAwB,CAAxB,CArBtB;;AAAA;;AAqBfC,EAAAA,WArBe;AAqBFnB,EAAAA,MArBE;;AAwBhB,MAAIY,GAAG,KAAK,CAAZ,EAAe;AAEbZ,IAAAA,MAAM,IAAI,IAAIiB,YAAY,CAACb,iBAA3B;;AAFa,4BAGUU,cAAc,CAAClB,IAAD,EAAOI,MAAP,EAAekB,OAAf,EAAwB,CAAxB,CAHxB;;AAAA;;AAGZG,IAAAA,UAHY;AAGArB,IAAAA,MAHA;AAId;;AAGD,MAAIY,GAAG,IAAI,CAAX,EAAc;AAEZZ,IAAAA,MAAM,IAAI,IAAIiB,YAAY,CAACb,iBAA3B;;AAFY,4BAGWU,cAAc,CAAClB,IAAD,EAAOI,MAAP,EAAekB,OAAf,EAAwB,CAAxB,CAHzB;;AAAA;;AAGXE,IAAAA,UAHW;AAGCpB,IAAAA,MAHD;AAIb;;AAED,MAAMa,SAAS,GAAGS,eAAe,CAACH,WAAD,EAAcC,UAAd,EAA0BC,UAA1B,CAAjC;;AAGA,MAAIpB,IAAI,KAAK,YAAb,EAA2B;AACzB,WAAO;AACLA,MAAAA,IAAI,EAAJA,IADK;AAELY,MAAAA,SAAS,EAAE;AAACE,QAAAA,KAAK,EAAEF,SAAR;AAAmBG,QAAAA,IAAI,EAAEJ;AAAzB,OAFN;AAGLmB,MAAAA,WAAW,EAAE;AAAChB,QAAAA,KAAK,EAAEY,WAAR;AAAqBX,QAAAA,IAAI,EAAE;AAA3B;AAHR,KAAP;AAKD;;AAID,MAAMgB,cAAwB,GAAG,EAAjC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,WAAW,CAACO,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,QAAME,cAAc,GAAGR,WAAW,CAACM,CAAC,GAAG,CAAL,CAAlC;AACA,QAAMG,YAAY,GAAGT,WAAW,CAACM,CAAD,CAAhC;AAEA,QAAMI,IAAI,GAAGlB,WAAW,CAACmB,QAAZ,CAAqBH,cAAc,GAAG,CAAtC,EAAyCC,YAAY,GAAG,CAAxD,CAAb;AACA,QAAMG,IAAI,GAAGC,mBAAmB,CAACH,IAAD,CAAhC;;AAIA,QAAIE,IAAI,GAAG,CAAX,EAAc;AACZP,MAAAA,cAAc,CAACS,IAAf,CAAoBN,cAApB;AACD;AACF;;AAEDH,EAAAA,cAAc,CAACS,IAAf,CAAoBvB,OAApB;AAEA,SAAO;AACLjB,IAAAA,IAAI,EAAJA,IADK;AAELY,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAEF,SAAR;AAAmBG,MAAAA,IAAI,EAAEJ;AAAzB,KAFN;AAGL8B,IAAAA,uBAAuB,EAAE;AAAC3B,MAAAA,KAAK,EAAEY,WAAR;AAAqBX,MAAAA,IAAI,EAAE;AAA3B,KAHpB;AAQLgB,IAAAA,cAAc,EAAE;AAACjB,MAAAA,KAAK,EAAE,IAAI4B,WAAJ,CAAgBX,cAAhB,CAAR;AAAyChB,MAAAA,IAAI,EAAE;AAA/C;AARX,GAAP;AAUD;;AAWD,SAASF,cAAT,CACElB,IADF,EAEEI,MAFF,EAGEkB,OAHF,EAIEN,GAJF,EAK0B;AACxB,MAAMY,YAAY,GAAG5B,IAAI,CAAC6B,UAAL,GAAkBzB,MAAvC;AACA,MAAM0B,YAAY,GAAGR,OAAO,GAAGN,GAAV,GAAgBK,YAAY,CAACb,iBAAlD;AACA,SAAO,CACL,IAAIa,YAAJ,CAAiBrB,IAAI,CAACiC,MAAL,CAAYC,KAAZ,CAAkBN,YAAlB,EAAgCA,YAAY,GAAGE,YAA/C,CAAjB,CADK,EAEL1B,MAAM,GAAG0B,YAFJ,CAAP;AAID;;AAYD,SAASJ,eAAT,CACEH,WADF,EAEEC,UAFF,EAGEC,UAHF,EAIgB;AACd,MAAI,EAAED,UAAU,IAAIC,UAAhB,CAAJ,EAAiC;AAC/B,WAAOF,WAAP;AACD;;AAED,MAAIyB,WAAW,GAAGzB,WAAW,CAACe,MAA9B;AACA,MAAIW,IAAI,GAAG,CAAX;;AAEA,MAAIxB,UAAU,IAAIA,UAAU,CAACa,MAA7B,EAAqC;AACnCU,IAAAA,WAAW,IAAIvB,UAAU,CAACa,MAA1B;AACAW,IAAAA,IAAI;AACL;;AAED,MAAIzB,UAAU,IAAIA,UAAU,CAACc,MAA7B,EAAqC;AACnCU,IAAAA,WAAW,IAAIxB,UAAU,CAACc,MAA1B;AACAW,IAAAA,IAAI;AACL;;AAED,MAAMhC,SAAS,GAAG,IAAII,YAAJ,CAAiB2B,WAAjB,CAAlB;;AACA,OAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,WAAW,CAACe,MAAZ,GAAqB,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/CpB,IAAAA,SAAS,CAACgC,IAAI,GAAGZ,CAAR,CAAT,GAAsBd,WAAW,CAACc,CAAC,GAAG,CAAL,CAAjC;AACApB,IAAAA,SAAS,CAACgC,IAAI,GAAGZ,CAAP,GAAW,CAAZ,CAAT,GAA0Bd,WAAW,CAACc,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAArC;AACD;;AAED,MAAIZ,UAAU,IAAIA,UAAU,CAACa,MAA7B,EAAqC;AACnC,SAAK,IAAID,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGZ,UAAU,CAACa,MAA/B,EAAuCD,EAAC,EAAxC,EAA4C;AAE1CpB,MAAAA,SAAS,CAACgC,IAAI,GAAGZ,EAAP,GAAW,CAAZ,CAAT,GAA0BZ,UAAU,CAACY,EAAD,CAApC;AACD;AACF;;AAED,MAAIb,UAAU,IAAIA,UAAU,CAACc,MAA7B,EAAqC;AACnC,SAAK,IAAID,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGb,UAAU,CAACc,MAA/B,EAAuCD,GAAC,EAAxC,EAA4C;AAE1CpB,MAAAA,SAAS,CAACgC,IAAI,GAAGZ,GAAP,IAAYY,IAAI,GAAG,CAAnB,CAAD,CAAT,GAAmCzB,UAAU,CAACa,GAAD,CAA7C;AACD;AACF;;AAED,SAAOpB,SAAP;AACD;;AAUD,SAAS2B,mBAAT,CAA6B3B,SAA7B,EAA8D;AAC5D,SAAON,IAAI,CAACgC,IAAL,CAAUO,aAAa,CAACjC,SAAD,CAAvB,CAAP;AACD;;AAQD,SAASiC,aAAT,CAAuBjC,SAAvB,EAAwD;AACtD,MAAIkC,IAAI,GAAG,CAAX;AAGA,MAAMC,OAAO,GAAGnC,SAAS,CAACqB,MAAV,GAAmB,CAAnB,GAAuB,CAAvC;;AACA,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,OAApB,EAA6Bf,CAAC,EAA9B,EAAkC;AAChCc,IAAAA,IAAI,IACF,CAAClC,SAAS,CAACoB,CAAC,GAAG,CAAL,CAAT,GAAmBpB,SAAS,CAAC,CAACoB,CAAC,GAAG,CAAL,IAAU,CAAX,CAA7B,KACCpB,SAAS,CAACoB,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBpB,SAAS,CAAC,CAACoB,CAAC,GAAG,CAAL,IAAU,CAAV,GAAc,CAAf,CADjC,CADF;AAGD;;AAED,SAAOc,IAAI,GAAG,CAAd;AACD","sourcesContent":["import {BinaryGeometry, BinaryGeometryType} from '@loaders.gl/schema';\n\nconst LITTLE_ENDIAN = true;\n\n/**\n * Parse individual record\n *\n * @param view Record data\n * @return Binary Geometry Object\n */\n// eslint-disable-next-line complexity\nexport function parseRecord(view: DataView, options?: {shp?: any}): BinaryGeometry | null {\n  const {_maxDimensions} = options?.shp || {};\n\n  let offset = 0;\n  const type: number = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  switch (type) {\n    case 0:\n      // Null Shape\n      return parseNull();\n    case 1:\n      // Point\n      return parsePoint(view, offset, Math.min(2, _maxDimensions));\n    case 3:\n      // PolyLine\n      return parsePoly(view, offset, Math.min(2, _maxDimensions), 'LineString');\n    case 5:\n      // Polygon\n      return parsePoly(view, offset, Math.min(2, _maxDimensions), 'Polygon');\n    case 8:\n      // MultiPoint\n      return parseMultiPoint(view, offset, Math.min(2, _maxDimensions));\n    // GeometryZ can have 3 or 4 dimensions, since the M is not required to\n    // exist\n    case 11:\n      // PointZ\n      return parsePoint(view, offset, Math.min(4, _maxDimensions));\n    case 13:\n      // PolyLineZ\n      return parsePoly(view, offset, Math.min(4, _maxDimensions), 'LineString');\n    case 15:\n      // PolygonZ\n      return parsePoly(view, offset, Math.min(4, _maxDimensions), 'Polygon');\n    case 18:\n      // MultiPointZ\n      return parseMultiPoint(view, offset, Math.min(4, _maxDimensions));\n    case 21:\n      // PointM\n      return parsePoint(view, offset, Math.min(3, _maxDimensions));\n    case 23:\n      // PolyLineM\n      return parsePoly(view, offset, Math.min(3, _maxDimensions), 'LineString');\n    case 25:\n      // PolygonM\n      return parsePoly(view, offset, Math.min(3, _maxDimensions), 'Polygon');\n    case 28:\n      // MultiPointM\n      return parseMultiPoint(view, offset, Math.min(3, _maxDimensions));\n    default:\n      throw new Error(`unsupported shape type: ${type}`);\n  }\n}\n\n// TODO handle null\n/**\n * Parse Null geometry\n *\n * @return null\n */\nfunction parseNull(): null {\n  return null;\n}\n\n/**\n * Parse point geometry\n *\n * @param view Geometry data\n * @param offset Offset in view\n * @param dim Dimension size\n */\nfunction parsePoint(view: DataView, offset: number, dim: number): BinaryGeometry {\n  let positions: Float64Array;\n  [positions, offset] = parsePositions(view, offset, 1, dim);\n\n  return {\n    positions: {value: positions, size: dim},\n    type: 'Point'\n  };\n}\n\n/**\n * Parse MultiPoint geometry\n *\n * @param view Geometry data\n * @param offset Offset in view\n * @param dim Input dimension\n * @return Binary geometry object\n */\nfunction parseMultiPoint(view: DataView, offset: number, dim: number): BinaryGeometry {\n  // skip parsing box\n  offset += 4 * Float64Array.BYTES_PER_ELEMENT;\n\n  const nPoints = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  let xyPositions: Float64Array | null = null;\n  let mPositions: Float64Array | null = null;\n  let zPositions: Float64Array | null = null;\n  [xyPositions, offset] = parsePositions(view, offset, nPoints, 2);\n\n  // Parse Z coordinates\n  if (dim === 4) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [zPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  // Parse M coordinates\n  if (dim >= 3) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [mPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  const positions = concatPositions(xyPositions, mPositions, zPositions);\n\n  return {\n    positions: {value: positions, size: dim},\n    type: 'Point'\n  };\n}\n\n/**\n * Polygon and PolyLine parsing\n *\n * @param view Geometry data\n * @param offset Offset in view\n * @param dim Input dimension\n * @param type Either 'Polygon' or 'Polyline'\n * @return Binary geometry object\n */\n// eslint-disable-next-line max-statements\nfunction parsePoly(\n  view: DataView,\n  offset: number,\n  dim: number,\n  type: BinaryGeometryType\n): BinaryGeometry {\n  // skip parsing bounding box\n  offset += 4 * Float64Array.BYTES_PER_ELEMENT;\n\n  const nParts = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n  const nPoints = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  // Create longer indices array by 1 because output format is expected to\n  // include the last index as the total number of positions\n  const bufferOffset = view.byteOffset + offset;\n  const bufferLength = nParts * Int32Array.BYTES_PER_ELEMENT;\n  const ringIndices = new Int32Array(nParts + 1);\n  ringIndices.set(new Int32Array(view.buffer.slice(bufferOffset, bufferOffset + bufferLength)));\n  ringIndices[nParts] = nPoints;\n  offset += nParts * Int32Array.BYTES_PER_ELEMENT;\n\n  let xyPositions: Float64Array | null = null;\n  let mPositions: Float64Array | null = null;\n  let zPositions: Float64Array | null = null;\n  [xyPositions, offset] = parsePositions(view, offset, nPoints, 2);\n\n  // Parse Z coordinates\n  if (dim === 4) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [zPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  // Parse M coordinates\n  if (dim >= 3) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [mPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  const positions = concatPositions(xyPositions, mPositions, zPositions);\n\n  // parsePoly only accepts type = LineString or Polygon\n  if (type === 'LineString') {\n    return {\n      type,\n      positions: {value: positions, size: dim},\n      pathIndices: {value: ringIndices, size: 1}\n    };\n  }\n\n  // for every ring, determine sign of polygon\n  // Use only 2D positions for ring calc\n  const polygonIndices: number[] = [];\n  for (let i = 1; i < ringIndices.length; i++) {\n    const startRingIndex = ringIndices[i - 1];\n    const endRingIndex = ringIndices[i];\n    // @ts-ignore\n    const ring = xyPositions.subarray(startRingIndex * 2, endRingIndex * 2);\n    const sign = getWindingDirection(ring);\n\n    // A positive sign implies clockwise\n    // A clockwise ring is a filled ring\n    if (sign > 0) {\n      polygonIndices.push(startRingIndex);\n    }\n  }\n\n  polygonIndices.push(nPoints);\n\n  return {\n    type,\n    positions: {value: positions, size: dim},\n    primitivePolygonIndices: {value: ringIndices, size: 1},\n    // TODO: Dynamically choose Uint32Array over Uint16Array only when\n    // necessary. I believe the implementation requires nPoints to be the\n    // largest value in the array, so you should be able to use Uint32Array only\n    // when nPoints > 65535.\n    polygonIndices: {value: new Uint32Array(polygonIndices), size: 1}\n  };\n}\n\n/**\n * Parse a contiguous block of positions into a Float64Array\n *\n * @param view  Geometry data\n * @param offset  Offset in view\n * @param nPoints Number of points\n * @param dim     Input dimension\n * @return Data and offset\n */\nfunction parsePositions(\n  view: DataView,\n  offset: number,\n  nPoints: number,\n  dim: number\n): [Float64Array, number] {\n  const bufferOffset = view.byteOffset + offset;\n  const bufferLength = nPoints * dim * Float64Array.BYTES_PER_ELEMENT;\n  return [\n    new Float64Array(view.buffer.slice(bufferOffset, bufferOffset + bufferLength)),\n    offset + bufferLength\n  ];\n}\n\n/**\n * Concatenate and interleave positions arrays\n * xy positions are interleaved; mPositions, zPositions are their own arrays\n *\n * @param xyPositions 2d positions\n * @param mPositions  M positions\n * @param zPositions  Z positions\n * @return Combined interleaved positions\n */\n// eslint-disable-next-line complexity\nfunction concatPositions(\n  xyPositions: Float64Array,\n  mPositions: Float64Array | null,\n  zPositions: Float64Array | null\n): Float64Array {\n  if (!(mPositions || zPositions)) {\n    return xyPositions;\n  }\n\n  let arrayLength = xyPositions.length;\n  let nDim = 2;\n\n  if (zPositions && zPositions.length) {\n    arrayLength += zPositions.length;\n    nDim++;\n  }\n\n  if (mPositions && mPositions.length) {\n    arrayLength += mPositions.length;\n    nDim++;\n  }\n\n  const positions = new Float64Array(arrayLength);\n  for (let i = 0; i < xyPositions.length / 2; i++) {\n    positions[nDim * i] = xyPositions[i * 2];\n    positions[nDim * i + 1] = xyPositions[i * 2 + 1];\n  }\n\n  if (zPositions && zPositions.length) {\n    for (let i = 0; i < zPositions.length; i++) {\n      // If Z coordinates exist; used as third coord in positions array\n      positions[nDim * i + 2] = zPositions[i];\n    }\n  }\n\n  if (mPositions && mPositions.length) {\n    for (let i = 0; i < mPositions.length; i++) {\n      // M is always last, either 3rd or 4th depending on if Z exists\n      positions[nDim * i + (nDim - 1)] = mPositions[i];\n    }\n  }\n\n  return positions;\n}\n\n/**\n * Returns the direction of the polygon path\n * A positive number is clockwise.\n * A negative number is counter clockwise.\n *\n * @param positions\n * @return Sign of polygon ring\n */\nfunction getWindingDirection(positions: Float64Array): number {\n  return Math.sign(getSignedArea(positions));\n}\n\n/**\n * Get signed area of flat typed array of 2d positions\n *\n * @param positions\n * @return Signed area of polygon ring\n */\nfunction getSignedArea(positions: Float64Array): number {\n  let area = 0;\n\n  // Rings are closed according to shapefile spec\n  const nCoords = positions.length / 2 - 1;\n  for (let i = 0; i < nCoords; i++) {\n    area +=\n      (positions[i * 2] + positions[(i + 1) * 2]) *\n      (positions[i * 2 + 1] - positions[(i + 1) * 2 + 1]);\n  }\n\n  return area / 2;\n}\n"],"file":"parse-shp-geometry.js"}